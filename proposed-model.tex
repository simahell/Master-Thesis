\documentclass[12pt,a4paper]{jbook}
\input{settings}
\begin{document}
\newpage

\chapter{提案モデル}
この章では、\ref{sec:ProposedModel-TemporalLogic}章で述べた記述法の応用例として、キャッシュを実装したウェブセキュリティモデルを提案する。

\section{概要}
本研究は基礎モデルで包括されていないウェブの要素としてキャッシュに注目する。
\ref{sec:bcpattack}節に述べた通りキャッシュを利用する攻撃が数多く存在しており、また、キャッシュは一般的なユーザにも利用される。
したがって、キャッシュに関連した脆弱性はウェブの利用者の多くに多大な影響を与えるため、ウェブの安全性を解析する上で不可欠な要素である。
本研究では、キャッシュを包括するウェブセキュリティモデルを提案し、\ref{sec:ProposedModel-TemporalLogic}節で述べた記述法を用いて提案モデルを実装する。

\section{提案モデルの能力}
\label{sec:ProposedModel-Power}
提案モデルは基礎モデルを基に作成する。
基礎モデルの能力は\ref{sec:based-model-power}節で述べており、以下に基礎モデルからの提案モデルでの変更点を各項目ごとに記述する。

\subsection{対象のシステムの構造と動作}
提案モデルでは、キャッシュの動作を包括することを目標とする。
しかし、キャッシュの動作を表現するには中継者やヘッダなど、基礎モデルで包括している項目では不足している要素がある。
したがって、提案モデルにはキャッシュの動作に加えて、その動作に使用されるキャッシュ以外の要素についても追加する。
以下に追加する要素を順に述べる。

\subsubsection{キャッシュの動作}
キャッシュはクライアント、サーバ、中継者のいずれかに属し、\ref{sec:cache}節で述べた「格納」、「再利用」、「検証」という三つの基本動作が可能である。
また、これらのキャッシュの動作はヘッダによって主に制御される。

\subsubsection{中継者}
中継者はクライアントやサーバとは異なるHTTPを構成する第三の要素であり、クライアントとサーバの通信経路上に存在する。
HTTP/1.1において、中継者は「プロキシ」、「ゲートウェイ」、「トンネル」の三種類が存在するが、これらのうちトンネルのみキャッシュを搭載しない。
したがって、キャッシュに注目する提案モデルはプロキシとゲートウェイのみを包括する。

まず、中継者は独自にリクエストやレスポンスを生成することはなく、取得したリクエストやレスポンスの回送を主に行う。
しかし、キャッシュを用いた場合にのみ、リクエストをサーバに送信しレスポンスを得ることなく、キャッシュの再利用をもってリクエストに応答することができる。
また、プロキシとゲートウェイはその通信内容の編集が可能である。

\subsubsection{HTTPヘッダ}
基礎モデルに含まれるヘッダではキャッシュの動作の表現に不十分であるため、表\ref{tb:ProposedModel-Headers}に挙げるヘッダを新たに追加する。

\begin{table}[htb]
\centering
\caption{提案モデルで新たに包括するヘッダ}
\label{tb:ProposedModel-Headers}
\begin{tabular}{lll}
ヘッダ名 & 用途 & 関連するキャッシュの動作 \\ \hline
if-modified-since & 条件付きリクエストに使用 & 検証 \\
if-none-match & 条件付きリクエストに使用 & 検証 \\
etag & レスポンス内のコンテンツの固有値 & 検証 \\
last-modified & レスポンス内のコンテンツの最終更新日 & 検証 \\
age & レスポンスの経過時間 & 格納・再利用 \\
cache-control & キャッシュの動作全般を制御 & 格納・再利用・検証 \\
date & レスポンスの生成時刻 & 格納・再利用 \\
expire & レスポンスの有効期限 & 格納・再利用 \\
\end{tabular}
\end{table}

また、表\ref{tb:ProposedModel-Headers}内のcache-controlヘッダはオプションによってキャッシュの動作を指定するため、そのオプションを付加可能とする。
利用可能なオプションを表\ref{tb:CacheControlOption}に挙げる。

\begin{table}[htb]
\centering
\caption{利用可能なcache-controlヘッダのオプション}
\label{tb:CacheControlOption}
\begin{tabular}{ll}
オプション名 & 用途 \\ \hline
max-age & レスポンスの有効期限を設定 \\
smax-age & 共有キャッシュでの有効期限を設定（その他の設定より優先） \\
no-cache & 検証無しに再利用できない \\
no-store & そのレスポンスを格納を禁止 \\
no-transform & コンテンツの編集を禁止 \\
max-stale & 期限切れである場合に許容できる時間 \\
min-fresh & 有効期限まで最低残り時間 \\
only-if-cached & キャッシュの再利用でのみ応答 \\
must-revalidate & 有効期限切れである場合、検証無しに再利用できない \\
proxy-revalidate & must-revalidateと同じ（個人キャッシュ以外で有効） \\
public & 共有キャッシュに格納してよい \\
private & 個人キャッシュに格納してよい \\
\end{tabular}
\end{table}

\subsubsection{ブラウザ}
基礎モデルでは表現の単純化のため、「ブラウザのメモリ領域は書き込みのみ可能」という制限がある。
しかし、この制限下ではキャッシュ内の格納レスポンスの削除や検証といった動作を実行することができず、キャッシュの動作を十分に表現することができない。
本研究で提案する時相論理の記述法を用いればレスポンスの削除といった動作を容易に表現できるため、提案モデルではこの制限を取り除く。

\subsection{脅威モデル}
提案モデルの脅威モデルは基礎モデルのものを継承している。
すなわち、三種類の攻撃者とユーザのふるまいを脅威モデルとして設定し、攻撃者にキャッシュと中継者に関する攻撃の能力を新たに付与する。
以下に、三種類の攻撃者それぞれに付与する能力を示す。

\begin{itemize}
\item Web Attacker\\
Web Attackerは複数の中継者を所有することができる。
しかし、その通信内容の編集や通信の遮断をすることはできず、内容をそのままに回送することのみ可能とする。
ただし、暗号化されていない場合、その通信内容を盗聴することは可能とする。
また、保有するクライアント、サーバ、中継者にキャッシュを搭載し、仕様通りに運用できる。
\item Network Attacker\\
Network Attackerは上記のWeb Attackerの能力を全て持つ。
これに加えて、中継者を用いた暗号化されていない通信内容の改ざんと、通信の遮断は可能とする。
\item Gadget Attacker\\
Gadget Attackerは中継者とキャッシュに関する能力は上記のNetwork Attackerと同様の能力を持つ。
\end{itemize}

また、正当なユーザのふるまいに対する制限に特に変更は加えない。

\subsection{安全性要件}
基礎モデルには二つの安全性要件が設定されており、これらの変更はない。
しかし、Security Invariantsにおける「ウェブの各構成要素」という文言にキャッシュや中継者が含まれることとなる。

\section{キャッシュの実装}
\ref{sec:ProposedModel-Power}節で述べた提案モデルの能力を基に、時相論理を用いてキャッシュを表現する。

\subsection{キャッシュクラスの作成}
キャッシュを表すクラスをCode\ref{code:CacheClass}のように記述する。
抽象クラスとしてCacheクラスを定義し、個人キャッシュを表すPrivateCacheクラス、共有キャッシュを表すPublicCacheクラスを定義する。

\begin{lstlisting}[caption=Cacheクラス, label=code:CacheClass]
abstract sig Cache{}
sig PrivateCache extends Cache{}
sig PublicCache extends Cache{}
\end{lstlisting}

また、CacheクラスにはCode\ref{code:LimitedCacheClass}に記述する制限を付与する。
付与される制限は以下の二点である。
\begin{itemize}
\item どのネットワーク上の端末にも属さないキャッシュは存在しない（1-4行目）
\item 個人キャッシュはクライアントに属し、共有キャッシュはサーバ、もしくは中継者に属する（6-9行目）
\end{itemize}

\begin{lstlisting}[caption=Cacheクラスの制限, label=code:LimitedCacheClass]
fact noOrphanedCaches {
	all c:Cache |
		one e:NetworkEndpoint | c = e.cache
}

fact PublicAndPrivate{
	all pri:PrivateCache | pri in HTTPClient.cache
	all pub:PublicCache | (pub in HTTPServer.cache) or (pub in HTTPIntermediary.cache)
}
\end{lstlisting}

また、キャッシュを搭載するため、Code\ref{code:EndPoint}のように、構成要素のクラスを変更する。
HTTPにおけるクライアント、サーバ、中継者を包括するHTTPConfirmistクラスにCacheクラスを追加する。
また、このとき各端末は多くとも一台のキャッシュしか保有することができないものとする。
\begin{lstlisting}[caption=HTTPを利用するウェブの構成要素, label=code:EndPoint]
abstract sig HTTPConformist extends NetworkEndpoint{cache : lone Cache}
\end{lstlisting}

\subsection{キャッシュの状態を表すクラス}
Code\ref{code:CacheStateClass}のように、時間軸上の各時点におけるキャッシュの状態を表現するクラスを作成する。
このクラスはStateクラスを継承し、作成した時相論理に関する述語を利用可能な形式とする。
また、この形式を用いるために、「一致要素」と「変化要素」を定義する必要がある。
まず、一致要素について考える。
キャッシュの状態遷移は同一のキャッシュの状態間で発生するため、一致要素はキャッシュとする。
これに従い、23行目のように一致要素を表すEqItemクラスを継承したCacheEqItemクラスを定義し、要素としてCacheクラスを定義する。
一方で、キャッシュ内の格納レスポンスの変化を表現するために、変化要素は格納レスポンスとする。
したがって、24行目のように変化要素を表すDifItemクラスを継承したCacheDifItemクラスを定義し、要素としてレスポンスの集合を定義する。
これにより、CacheStateクラスはあるキャッシュのある時点での格納レスポンスを表すクラスとして作成される。

\begin{lstlisting}[caption=キャッシュの状態を表すクラス, label=code:CacheStateClass]
sig CacheState extends State{}{
	eq in CacheEqItem
	dif in CacheDifItem

	eq.cache in PrivateCache implies
        all res:HTTPResponse | res in dif.store implies
                {
                    (one op:Maxage | op in res.headers.options) or
                    (one d:DateHeader, e:ExpiresHeader | d in res.headers and e in res.headers)
                }

    eq.cache in PublicCache implies
        all res:HTTPResponse | res in dif.store implies
                {
                    (one op:Maxage | op in res.headers.options) or
                    (one op:SMaxage | op in res.headers.options) or
                    (one d:DateHeader, e:ExpiresHeader | d in res.headers and e in res.headers)
                }

    all res:HTTPResponse | res in dif.store implies
        one h:AgeHeader | h in res.headers
}
sig CacheEqItem extends EqItem{cache: one Cache}
sig CacheDifItem extends DifItem{store: set HTTPResponse}
\end{lstlisting}

また、Code\ref{code:CacheStateClass}の5-22行目には、CacheStateクラスに以下の条件が記される。
これは、HTTP/1.1の仕様に従ったキャッシュの動作を表現したものである。
\begin{itemize}
\item 個人キャッシュの格納レスポンスのヘッダには、cache-controlヘッダのmax-ageオプション、もしくはdateヘッダとexpireヘッダが一つ含まれる
\item 共有キャッシュの格納レスポンスのヘッダには、cache-controlヘッダのmax-ageオプション、s-maxageオプション、dateヘッダとexpireヘッダのいずれかが一つ含まれる
\item キャッシュの格納レスポンスには、必ずageヘッダが一つ含まれる
\end{itemize}

\color{red}
さらに、これらに加えてCacheState、StateTransactionクラスにはCode\ref{code:LimitedCacheStateClass}に記す条件を付与する。
\color{black}
これらは、モデルをAlloy上で実装する際に必要となる項目である。
\begin{lstlisting}[caption=CacheStateクラスの制限, label=code:LimitedCacheStateClass]
fact noMultipleItems{
	no disj i,i':CacheEqItem | i.cache = i'.cache
	no disj i,i':CacheDifItem | i.store = i'.store
}

fact CacheInTransaction{
	all tr:HTTPTransaction |
		(some tr.request.(from + to).cache implies tr in StateTransaction)

	all str:StateTransaction |{
		str.beforeState.eq.cache = str.request.(from + to).cache
		some str.(request + re_res) implies str.afterState.eq.cache = str.beforeState.eq.cache
	}
}
\end{lstlisting}
まず、1-4行目では同一内容の状態クラスのインスタンスが複数存在しないことを表している。
もし、同一内容のインスタンスが複数存在することを許した場合、単純なインスタンスの比較によってのみでは状態が変化したかどうかを判定できない。
この制限は状態変化の比較を容易にする。
\color{red}
また、10-14行目では、キャッシュが搭載されている端末が通信を行った場合に、そのキャッシュの状態が必ずStateTransactionクラスで表現されることを表している。
この記述により、通信が行われた場合にはそのリクエストとレスポンス時の状態が必ず表現され、全ての時間軸において変化を捉えることが可能になる。
\color{black}

\section{中継者の実装}
\section{提案モデルの制限事項}


\end{document}
