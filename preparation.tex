\documentclass[12pt,a4paper]{jbook}
\input{settings}
\begin{document}
\newpage

\chapter{準備}
\section{形式手法}
\subsection{概要}
システムの安全性検査において、数学的な証明を利用する形式手法が存在する。
この手法では、入力となるセキュリティモデル（\ref{sec:SecurityModel}節参照）を作成し、それを用いたモデル検査によりシステムの安全性を確認できる。

\color{red}
実際にシステム開発に形式手法を利用する際には以下の手順を行う。
\begin{enumerate}
\item モデル作成\\
設計したシステムをセキュリティモデル（\ref{sec:SecurityModel}節参照）として表現する
\item モデル検査\\
用意したセキュリティモデルに対してモデル検査を実施する
\item 結果分析\\
得られた出力結果からシステムの仕様定義の漏れや脆弱性を発見し、その対策法を考案する
\item モデル修正\\
３．で考案した対策法をセキュリティモデルに反映し、「２．モデル検査」から繰り返す
\end{enumerate}
\color{black}


\subsection{Alloy Analyzer}
Alloy Analyzerは形式手法に利用できるモデル検査ツールの１つである。
検査対象のシステムのを表現したセキュリティモデルをAlloyという専用の言語で記述し、これを入力として実行する。
\color{red}
この実行により、モデルが取りうる状態のうち任意のある条件満たしたもの、もしくは、その条件を満たさないものの２通りの出力を得ることができる。
前者は主にセキュリティモデルが正しく実装されていることを確認するための事例研究に利用する。
システムが包括していると想定される事例を条件に記述することで、その事例を含むシステムの挙動が出力され、その事例が正しく表現されていることを確認できる。
一方で、後者の出力結果は主にシステムの安全性解析に用いる。
システムが満たしているべき安全性要件を条件に記述することで、その要件を満たさないシステムの挙動が出力される。
この挙動には安全性要件を侵す脆弱性が含まれているため、この結果の解析によって脆弱性の発見が可能である。
\color{black}

また、Alloy Analyzerが他の形式手法ツールとは異なる点として、実行結果をグラフとして得られるため、より直観的な利用が可能であることが挙げられる。

\subsection{時相論理}
\label{sec:TemporalLogic}
時相論理は通常の命題論理に「常に～である」「次の状態では～である」といった、いくつかの論理演算子を加えることで時間変化を表現できるよう拡張したものである。
時相論理において記述した論理式は、その性質から以下の２種類に分類できる。
\begin{itemize}
\item 状態論理式\\
状態論理式はモデルが取りうる各状態に対して真偽が定まる
\item パス論理式\\
パスはそのモデルにおいて状態が変化していく遷移を表す。
パス論理式はモデルが取りうるパスに対して真偽が定まる。
\end{itemize}

また、時相論理にもいくつか種類が存在し、それぞれで扱える演算子が異なるため表現能力が異なる。
以下に形式手法に用いられる３つの時相論理を挙げる。
\begin{itemize}
\item LTL（linear temporal logic / 線形時相論理）\\
LTLはパス論理式のみを表現可能である。
\item CTL（compuational tree logic / 計算木論理）\\
CTLは状態論理式のみを表現可能である。
\item CTL*\\
CTL*はパス論理式、及び、状態論理式のどちらも表現可能である。
また、上記のLTLとCTLはCTL*の部分論理である。
\end{itemize}

\section{World Wide Web}
\color{red}
World Wide Web（以下、「ウェブ」とする）はハイパーテキストを記述するHTMLが用いられているドキュメントをインターネット上で提供するシステムである。
ハイパーテキストとはあるドキュメント内に別のドキュメントへのリンクを埋め込み、ドキュメント間の関連性を表現可能とする技術である。
\color{black}
ウェブにおいてはそのリンクを用いてインターネット上に存在する様々なドキュメントの繋がりを表現し、参照先のドキュメントの表示やダウンロードを容易にする。
また、この利便性に加えて、ウェブを利用するためのソフトウェアであるブラウザや検索エンジンの技術向上により、ウェブは急速に普及し現代社会において不可欠なものとなっている。

\section{Hypertext Transfer Protocol}
\label{sec:http}
\subsection{プロトコルの概要}
Hypertext Transfer Protocol（以下、「HTTP」とする）は様々なデータの形式や通信目的に共通して利用できる汎用的な通信を実現するためのプロトコルとして設計された。
このHTTPは、ウェブの環境に合わせて仕様変更がなされており様々なバージョンが存在する。
本研究では、現在一般的に使用されることが多いHTTP/1.1\cite{rfc7230,rfc7231,rfc7232,rfc7233,rfc7234,rfc7235}と、その下位互換性を考慮しHTTP/1.0\cite{rfc1945}を対象に考える。

HTTPにおける基本的な通信は、クライアントから発信されるリクエストとサーバからのレスポンスの２段階の通信で成り立つ。
まず、クライアントは要求するリソースを指定したリクエストを、対象のリソースを所有するサーバに送信する。
そして、サーバはリクエストの受信後に、対象のリソースを含めたレスポンスをクライアントに送信する。
以上の手順によって、クライアントは要求したリソースを取得することができる。

また、HTTPのプロトコルは汎用的な利用を目的とするため、プロトコル上で定義される内容は以下の３つである。
\begin{itemize}
\item 通信内容の構文
\item 通信内容の利用意図
\item 通信相手に期待するふるまい
\end{itemize}
送信者は定義された構文に従いパケットを生成し送信することで、通信の意図と通信相手に期待する動作を伝えることができ、受信者はこれに伴ったふるまいをとることができる。
さらに、このように単純な設計にしておくことで、HTTP以外の異なるプロトコル間での通信をHTTPを用いて中継するといった利用方法も可能となる。

\subsection{HTTP通信を構成する要素}
HTTPの通信を行うプログラムには様々な役割があり、それらは役割ごとに「クライアント」「サーバ」「中継者」の３種類に分類される。
また、複数の通信が並行して行われているような場合には同時に複数の役割を果たしていることもあり、同一のプログラムがとある接続ではクライアント、他の接続ではサーバとして動作することも起こりうる。

\subsubsection{クライアント}
HTTPにおけるクライアントは、リクエストを送信するためにサーバへの接続を確立するプログラムのことを指す。
一般的には、ウェブブラウザやスマートフォンなどがこの役割を果たすことが多い。

\subsubsection{サーバ}
HTTPにおけるサーバは、受信したリクエストに対して要求されたふるまいを行い結果をレスポンスとしてクライアントへ送信するプログラムのことを指す。
サーバとして動作しているプログラムはその性質上、企業などのサービス提供者が運用している場合が多い。

\subsubsection{中継者}
\label{sec:intermediary}
HTTP通信ではクライアントとレスポンスの経路間で複数のプログラムを経由する場合があり、このプログラムを中継者と呼ぶ。
中継者にも様々な機能が存在し、それらに合わせて３つの種類がある。
\begin{enumerate}
\item プロキシ\\
プロキシは通過するリクエストやレスポンスを編集することができ、通信内容を事前に指定した形式へ変換したり、許可されていない内容を削除するといった機能を持つ。
また、あるローカルネットワークに属する複数のクライアントで共通のプロキシを利用することで、セキュリティの向上やキャッシュを用いた通信の効率化を実現することも可能である。
\item ゲートウェイ\\
ゲートウェイはローカルネットワークとグローバルネットワークの経由地点として機能する。
まず、ゲートウェイはグローバルネットワーク側から見るとサーバとしてふるまい、リクエストを受信する。
それらのリクエストに対して、ローカルネットワーク側からはクライアントとしてふるまい、ローカルネットワーク内の複数のサーバから最適なサーバに対してリクエストを送信する。
最後に、ローカルネットワークから得られた結果を踏まえてレスポンスを作成し、グローバルネットワークの本来のリクエストの送信元に対して返答する。
このゲートウェイを利用することで、サーバの処理負荷分散、キャッシュによるネットワークの負荷軽減、リソースを保持しているサーバの情報等の秘匿化を実現できる。
また、これに加えて、ローカルネットワークにおいてはHTTPでの通信を強要しないため、HTTPとその他の通信プロトコル間の翻訳といった機能も実現できる。
\item トンネル\\
トンネルは通信内容の変更を行わず、２つの接続をただ中継するようにふるまう。
これにより、認証を必要とする通信において、認証成功後にトンネルを作成しておくことでその経路の通信を確立しておくことができる。
また、上記のプロキシとゲートウェイと異なり、トンネル自体はキャッシュを保有していない。
\end{enumerate}

\subsection{HTTP Over TLS}
\label{sec:https}
HTTP Over TLS\cite{https}（以下、「HTTPS」とする）は、簡単に通信内容を傍受される可能性のあるHTTPを拡張し、安全性を向上させた暗号通信プロトコルである。
HTTPに以下の機能を持つSecure Socket Layer/Transport Layer Security(SSL/TLS)を加えることで通信の安全性を確保している。
\begin{itemize}
\item 通信内容の暗号化
\item 通信相手の認証
\item 通信内容の改ざんの検出
\end{itemize}

\section{キャッシュ}
\label{sec:cache}
\subsection{概要}
\color{red}
一般的にキャッシュは２つの意味を指す。
１つ目は、パソコン内の部品であるキャッシュメモリのことを指し、ハードウェア面でプロセッサ等の処理速度の向上を目的とするものである。
２つ目は、ウェブの分野において、通信内容を一時的に保管するキャッシュ機能のことを指す。
これらのうち本研究では、後者のウェブにおけるキャッシュについて取り扱う。

以前は、ウェブの通信速度が遅く通信の最大容量が小さかったため、少ない通信量で効率の良い通信を実現することが重要であった。
そこで、ウェブページに埋め込まれているデータの中には、画像や動画等といった頻繁に更新されないものが存在することに着目し、それらに関してはアクセスの度に通信を行う必要がないと考えられた。
このようなデータについて１度目の通信で得たレスポンスを保存しておき、以降同様のデータに対するリクエストにはその保存されているレスポンスを再利用して応答することで、通信量と通信速度ともに向上させることができる。
\color{black}

また、このキャッシュの制御は主にリクエストとレスポンスに含まれるヘッダを用いて行う。
例えば、cache-controlヘッダに適切なオプションを付与することにより、キャッシュによる再利用の不許可やレスポンスの格納の禁止といった制限を実現できる。

\subsection{キャッシュの種別}
キャッシュは以下の２つの種類が存在する。
\begin{itemize}
\item 個人キャッシュ \\
ブラウザなどのクライアントに存在するキャッシュ
\item 共有キャッシュ \\
中継者やサーバに存在するキャッシュ
\end{itemize}
個人キャッシュはそれが属するクライアントにのみ利用され、その他のユーザが利用することはない。
その一方で、中継者やサーバは様々な端末からの接続が行われる場所であり、共有キャッシュも共同で利用される。
例えば、個人キャッシュで再利用するレスポンスはそのブラウザが一度は利用したことがあるレスポンスとなるが、共有キャッシュの場合は事前に他者が利用したレスポンスを再利用する可能性がある。

\subsection{キャッシュの基本動作}
キャッシュには、「格納」「再利用」「検証」の大きく３つの基本的な機能が存在する。

\begin{enumerate}
\item 格納\\
キャッシュを保有する機器が、レスポンスの再利用を目的としてキャッシュに一時保存することを「格納」という。
キャッシュへ格納される条件として、キャッシュに格納された場合の有効期限がそのレスポンスのヘッダに明記されており、かつ、格納を許可しないといった制限がないことが求められる。
\item 再利用\\
キャッシュを持つ通信者がリクエストを送信、及び、受信する際に、そのリクエストが求めるリソースがキャッシュに格納されているレスポンスに含まれており、キャッシュによるレスポンスの再利用を禁止する記述がない場合、その通信者はその格納レスポンスを複製し応答として再利用できる。
有効期限が切れている場合や、検証が強制されている場合には以下の検証動作を行う必要がある。
\item 検証\\
キャッシュ内のレスポンスが現在も再利用可能であるかをオリジンサーバ（そのレスポンスの生成元であるサーバ）に問い合わせる動作を「検証」という。
その問い合わせは、専用のヘッダを含む「条件付きリクエスト」を生成することで行う。
この条件付きリクエストに対するレスポンスとして、再利用可能であることを表すレスポンス、もしくは、再度キャッシュに格納するための最新のレスポンスを受け取ることができる。
\end{enumerate}

\section{関連研究}
現在、形式手法は様々な安全性解析に利用されており、それに向けたセキュリティモデルの構成の整理がなされている\cite{security_modeling_and_analysis}。
セキュリティモデルは大きく３つの要素に分割でき、「検査対象の構造やふるまい」、「脅威モデル」、「安全性要件」で構成される。
これにより、想定した「脅威モデル」によって解析対象が「安全性要件」を満たさない状態が存在するか、また存在する場合にはどのような状態であるのかを考察することが形式手法である。

%この形式手法をウェブの安全性解析に用いた研究が存在する\cite{based-model,cookie-model}。
%これらの研究で実装されたセキュリティモデルを基に本研究では拡張を行っており、詳細は\ref{sec:existing-model}章に述べる。

本研究では形式手法をウェブというシステムの安全性解析に用いているが、形式手法はシステムのみに限らず、様々な検査対象に利用可能な手法である。
まず、形式手法は様々なネットワークプロトコルの安全性解析に用いられている。
Arnaudら\cite{modeling-and-verifying-ad-hoc}はアドホックネットワークにおけるルーティングプロトコルに対して、その正確性を確認し、また、その計算速度が多項式時間で可能となる条件を発見している。
Brusoら\cite{formal-verification-of-privacy-for}は、ICチップの非接触による近距離無線通信\cite{formal-verification-of-privacy-for}を対象に、２つの安全性要件を定義し一般的に用いられているプロトコルがそれらを満たすために必要な条件を発見した。

またその他の形式手法の利用例として、Nearら\cite{finding_security_bugs_in_web}は特定の要素を含むウェブアプリケーションにおいて、必ず安全性を満たすアクセスパターンを発見している。
Kleinら\cite{sel4_formal_verification_of_an}はseL4というOSのマイクロカーネルに対して、想定されていない動作が存在するか解析し、結果としてそのような動作が起こりえないことを証明した。
Shinら\cite{towards_formal_analysis_of_the}はAndoroid OSの安全性の確認を行っている。
Lieら\cite{specifying_and_verifying_hardware_for_tamper}は耐タンパー性を持つプロセッサが耐タンパー性を失う状態の有無を検査し、その状態に陥る条件を発見している。

また、本研究では特にHTTPでのウェブの安全性解析に取り組んでおり、HTTPの運用には様々な脆弱性が存在する。
Jiaら\cite{bcpattack}はブラウザキャッシュを利用したBrowser Cache Poisoning Attackを発見し、これにより攻撃対象のブラウザに任意の挙動をさせることが可能になる。
Ryckら\cite{cookie-model}らはCross-site Request Forgeryという攻撃手法を対象とし、ブラウザでのCookieを用いた対策法の考案を行っている。
Ogawaら\cite{WCD}らは中継者のキャッシュを利用したWeb Cache Deception Attackを発見し、この攻撃により攻撃者は本来アクセス権限を持たないファイルを取得することが可能になる。
これに加えて、HTTPにはその拡張であるHTTPS（\ref{sec:https}節参照）が存在するが、HTTPSにも脆弱性が報告されている\cite{poodle}。
このような背景から、HTTPSに更なる拡張を行い安全性を向上させた、HTTP Strict Transport Security\cite{hsts}、Public Key Pinning Extension for HTTP\cite{hpkp}が考案され運用が始められている。
しかし、サーバ管理者による設定が不十分であることにより、これらのプロトコルの持つ安全性が維持されていないという現状が報告されている\cite{hstshpkp}。
今後、これらのプロトコルの解析を行い、十分な安全性を保障するための設定基準等を定める必要がある。

\end{document}
